\chapter{Arquitectura general de Linux}

En este capítulo se describe la arquitectura general del kernel de Linux que se va a utilizar en el presente proyecto. Como el diseño anterior se ha considerado válido en el entorno de pruebas, obteniendo muy buenos resultados de rendimiento, en esta sección se explicarán los cambios que serán tenidos en cuenta para hacer que el anterior diseño funcione todavía mejor.

Una de las primeras decisiones de diseño que hay que hacer es la elección de la versión a la que se va a migrar. Según lo que se ha analizado, la interfaz hacia los módulos y drivers de kernel se ha mantenido de la misma forma, permitiendo así que el trabajo de migración para Ksensor se integre de una forma más sencilla que la anterior migración, de espacio de usuario a espacio de kernel.

El principal problema de la migración de Ksensor son las funciones específicas que se han implementado para su correcto funcionamiento, las cuales utilizan estructuras internas normalmente no visibles para los módulos, lo que hace que sean incompatibles.

A continuación, se intentarán explicar las diferencias conceptuales entre el kernel 2.6.15 y 3.6 en los puntos relevantes para la correcta implementación de este proyecto, además de explicaciones de los diseños que se han tomado en el kernel oficial.

\section{Estrategia de captura de paquetes}
Se explicará la estrategia actual para la captura de paquetes, que será relevante para explicar las razones por las que esta parte necesita un rediseño. Se empezará desde el nivel más cercano a la red, explicando como se tratan las interrupciones y a continuación se explicará como se tratan los paquetes capturados.

\subsection{Tratamiento de interrupciones para la captura de tráfico}
La captura de paquetes es una operación de gran delicadeza en el entorno en el que trabaja este proyecto. En primer lugar es necesario entender que la captura de paquetes la hace una NIC (Network Interface Controller), y a través de una interrupción hardware avisa al sistema operativo que tiene paquetes para ser recogidos de su memoria interna.

El sistema por lo tanto, recoge los paquetes, y la NIC vuelve a disponer de ese espacio para la recepción de más paquetes. El problema está en que si el sistema no es lo suficiente rápido, la tarjeta podría quedarse sin memoria interna libre para la recepción de más datos de red, y acabaría rechazando paquetes hasta que el sistema liberara su memoria. A continuación se describe el método usado para la adquisición de paquetes de la tarjeta de red.

El mecanismo, propuesto por \cite{JMKR96}, es la unión entre la técnica de polling, donde tras determinado tiempo se consulta a la tarjeta si tiene paquetes para procesar, y la técnica de interrupciones, donde la tarjeta interrumpe al sistema cada vez que recibe un paquete, se llama NAPI, y proporciona un rendimiento muy bueno comparado con cualquiera de los mecanismos anteriores en casos generales.

En definitiva, cuando llega el primer paquete, se produce una interrupción hardware y se ejecuta la rutina de atención correspondiente a esa interrupción. En esta rutina se notifica al sistema acerca de la llegada de nuevos paquetes que necesitan ser recogidos, y a continuación se deshabilitan las interrupciones. Cuando el sistema lo considere oportuno, se ejecutará la tarea del kernel encargada de la recepción de paquetes, que hará un polling sobre la tarjeta de red mientras sigan llegando paquetes.

Finalmente, se vuelven a habilitar las interrupciones. De esta manera, si la tasa de llegada es baja, el sistema se comporta como un sistema basado en interrupciones, y si aumenta, se capturan más paquetes por interrupción, asemejándose a un sistema basado en polling.

Aunque este método de captura ya había sido implantado a la hora de realizar el proyecto \cite{KABO05}, ha habido un cambio que ha durado alrededor de 1 año (2009) que hace que la implementación del mecanismo de polling y el modo de gestionar las interfaces virtuales  que utiliza Ksensor quede totalmente obsoleto.

\subsection{Tratamiento de los paquetes capturados}
Una vez se ha entendido como se capturan los paquetes, queda por explicar como se procesan en el sistema. Lo primero a explicar para entender la estructura, es la manera en la que están diseñadas las rutinas de servicio a la interrupción.

A partir de ahora, y aunque estos términos no sean los correctos, se utilizarán dos palabras para hacer referencia a las diferentes rutinas de interrupción. Con hardirq nos referiremos a la RSI hardware que tiene el controlador de cualquier tarjeta de red, y softirq se referirá al proceso planificado desde la hardirq para hacer el trabajo que requiere atender correctamente las necesidades de la tarjeta.

La hardirq es una rutina muy corta que se encarga únicamente de planificar la softirq. En la softirq se debe dar cabida a todo el procesamiento que requiere la atención de la tarjeta, con un límite. En caso de ejecutarse durante el tiempo asignado o la cantidad de paquetes a procesar, deberá salir, y volver a ser planificado.

La softirq tiene una lista de las interfaces a las que hacer poll, planificadas previamente en sus correspondientes hardirqs. En la rutina, se llama iterativamente a las funciones de poll de cada tarjeta, y esta función de poll se encarga de recoger cada paquete de la interfaz y pasárselo a una función que se encargará de procesar cada paquete por separado.

\label{sec:gro}
Un cambio importante que es digno de tener en consideración a la hora de justificar un mejor rendimiento del sistema en la captura, es el mecanismo GRO descrito en \cite{DAVE10}, que hace que lo explicado en el anterior párrafo no sea tan simple.

Hasta antes de su implantación, el mecanismo de captura se basaba en la recepción de paquetes, y tras comprobar algunos parámetros de integridad del paquete, se introducía el paquete en la cola de análisis del sistema. Este mecanismo hace que los paquetes sean tratados de uno en uno.

Por el contrario, con la nueva técnica, se crean una especie de super paquetes que se componen de todos los paquetes que tienen varios parámetros en común. De esta manera, se consigue fundir los datos de los niveles de protocolos más bajos ahorrando computación para después procesarlos como uno solo.

\subsection{Administración del interfaz y sus colas de recepción}
La implementación anterior, si bien entendía como necesaria el uso del sistema descrito en \cite{JMKR96}, había integrado esa lógica dentro del resto de la estructura encargada de la administración de la tarjeta de red. Lo cual hizo que con el paso de los años, cuando empezaron a salir las tarjetas con varias interfaces de red y una cola de recepción para cada una, donde cabía la posibilidad de que solo se hubieran recibido paquetes en una de ellas, se decidiera separar de una manera virtual estas colas.

Por lo tanto, se empezó a separar de manera lógica la gestión del interfaz físico y la administración de las colas virtuales. Haciendo que por ese motivo, ahora que ya está totalmente separado uno del otro, el diseño de Ksensor se debe adaptar a la nueva lógica del kernel de captura de paquetes.